# HG changeset patch
# Parent d914d5c1f803879d232dfc4633bd535b4885cbc9
# User Fernando Jim√©nez <ferjmoreno@gmail.com>

diff --git a/dom/system/gonk/RILContentHelper.js b/dom/system/gonk/RILContentHelper.js
--- a/dom/system/gonk/RILContentHelper.js
+++ b/dom/system/gonk/RILContentHelper.js
@@ -63,16 +63,18 @@ const RIL_IPC_MSG_NAMES = [
   "RIL:SelectNetwork",
   "RIL:SelectNetworkAuto",
   "RIL:CallStateChanged",
   "RIL:VoicemailNotification",
   "RIL:VoicemailInfoChanged",
   "RIL:CallError",
   "RIL:CardLockResult",
   "RIL:USSDReceived",
+  "RIL:GetIMEI:Return:OK",
+  "RIL:GetIMEI:Return:KO",
   "RIL:SendMMI:Return:OK",
   "RIL:SendMMI:Return:KO",
   "RIL:CancelMMI:Return:OK",
   "RIL:CancelMMI:Return:KO",
   "RIL:StkCommand",
   "RIL:StkSessionEnd",
   "RIL:DataError",
   "RIL:SetCallForwardingOption",
@@ -532,16 +534,28 @@ RILContentHelper.prototype = {
                                   Cr.NS_ERROR_UNEXPECTED);
     }
     let request = Services.DOMRequest.createRequest(window);
     info.requestId = this.getRequestId(request);
     cpmm.sendAsyncMessage("RIL:SetCardLock", info);
     return request;
   },
 
+  getIMEI: function getIMEI(window) {
+    debug("Get IMEI");
+    if (!window) {
+      throw Components.Exception("Can't get window object",
+                                 Cr.NS_ERROR_EXPECTED);
+    }
+    let request = Services.DOMRequest.createRequest(window);
+    let requestId = this.getRequestId(request);
+    cpmm.sendAsyncMessage("RIL:GetIMEI", {requestId: requestId});
+    return request;
+  },
+
   sendMMI: function sendMMI(window, mmi) {
     debug("Sending MMI " + mmi);
     if (!window) {
       throw Components.Exception("Can't get window object",
                                  Cr.NS_ERROR_EXPECTED);
     }
     let request = Services.DOMRequest.createRequest(window);
     let requestId = this.getRequestId(request);
@@ -958,16 +972,30 @@ RILContentHelper.prototype = {
           this.fireRequestError(msg.json.requestId, msg.json.errorMsg);
         }
         break;
       case "RIL:USSDReceived":
         let res = JSON.stringify({message: msg.json.message,
                                   sessionEnded: msg.json.sessionEnded});
         Services.obs.notifyObservers(null, kUssdReceivedTopic, res);
         break;
+      case "RIL:GetIMEI:Return:OK":
+        debug("RIL:GetIMEI:Return:OK " + JSON.stringify(msg.json));
+        request = this.takeRequest(msg.json.requestId);
+        if (request) {
+          Services.DOMRequest.fireSuccess(request, msg.json.result);
+        }
+        break;
+      case "RIL:GetIMEI:Return:KO":
+        debug("RIL:GetIMEI:Return:KO " + JSON.stringify(msg.json));
+        request = this.takeRequest(msg.json.requestId);
+        if (request) {
+          Services.DOMRequest.fireError(request, msg.json.errorMsg);
+        }
+        break;
       case "RIL:SendMMI:Return:OK":
       case "RIL:CancelMMI:Return:OK":
         this.handleSendCancelMMIOK(msg.json);
         break;
       case "RIL:SendMMI:Return:KO":
       case "RIL:CancelMMI:Return:KO":
         request = this.takeRequest(msg.json.requestId);
         if (request) {
diff --git a/dom/system/gonk/RadioInterfaceLayer.js b/dom/system/gonk/RadioInterfaceLayer.js
--- a/dom/system/gonk/RadioInterfaceLayer.js
+++ b/dom/system/gonk/RadioInterfaceLayer.js
@@ -85,16 +85,17 @@ const RIL_IPC_TELEPHONY_MSG_NAMES = [
 const RIL_IPC_MOBILECONNECTION_MSG_NAMES = [
   "RIL:GetRilContext",
   "RIL:GetAvailableNetworks",
   "RIL:SelectNetwork",
   "RIL:SelectNetworkAuto",
   "RIL:GetCardLock",
   "RIL:UnlockCardLock",
   "RIL:SetCardLock",
+  "RIL:GetIMEI",
   "RIL:SendMMI",
   "RIL:CancelMMI",
   "RIL:SendStkResponse",
   "RIL:SendStkMenuSelection",
   "RIL:SendStkTimerExpiration",
   "RIL:SendStkEventDownload",
   "RIL:RegisterMobileConnectionMsg",
   "RIL:SetCallForwardingOption",
@@ -451,16 +452,20 @@ RadioInterfaceLayer.prototype = {
       case "RIL:UnlockCardLock":
         this.saveRequestTarget(msg);
         this.unlockCardLock(msg.json);
         break;
       case "RIL:SetCardLock":
         this.saveRequestTarget(msg);
         this.setCardLock(msg.json);
         break;
+      case "RIL:GetIMEI":
+        this.saveRequestTarget(msg);
+        this.getIMEI(msg.json.requestId);
+        break;
       case "RIL:SendMMI":
         this.saveRequestTarget(msg);
         this.sendMMI(msg.json);
         break;
       case "RIL:CancelMMI":
         this.saveRequestTarget(msg);
         this.cancelMMI(msg.json);
         break;
@@ -622,16 +627,19 @@ RadioInterfaceLayer.prototype = {
         break;
       case "iccmbdn":
         this.handleICCMbdn(message);
         break;
       case "USSDReceived":
         debug("USSDReceived " + JSON.stringify(message));
         this.handleUSSDReceived(message);
         break;
+      case "getIMEI":
+        this.handleGetIMEI(message);
+        break;
       case "sendMMI":
       case "sendUSSD":
         this.handleSendMMI(message);
         break;
       case "cancelMMI":
       case "cancelUSSD":
         this.handleCancelMMI(message);
         break;
@@ -1675,16 +1683,23 @@ RadioInterfaceLayer.prototype = {
   },
 
   handleUSSDReceived: function handleUSSDReceived(ussd) {
     debug("handleUSSDReceived " + JSON.stringify(ussd));
     gSystemMessenger.broadcastMessage("ussd-received", ussd);
     this._sendTargetMessage("mobileconnection", "RIL:USSDReceived", ussd);
   },
 
+  handleGetIMEI: function handleGetIMEI(message) {
+    debug("handleGetIMEI " + JSON.stringify(message));
+    let messageType = message.success ? "RIL:GetIMEI:Return:OK" :
+                                        "RIL:GetIMEI:Return:KO";
+    this._sendRequestResults(messageType, message);
+  },
+
   handleSendMMI: function handleSendMMI(message) {
     debug("handleSendMMI " + JSON.stringify(message));
     let messageType = message.success ? "RIL:SendMMI:Return:OK" :
                                         "RIL:SendMMI:Return:KO";
     this._sendRequestResults(messageType, message);
   },
 
   handleCancelMMI: function handleCancelMMI(message) {
@@ -1968,16 +1983,21 @@ RadioInterfaceLayer.prototype = {
                              callIndex: callIndex});
   },
 
   getAvailableNetworks: function getAvailableNetworks(requestId) {
     this.worker.postMessage({rilMessageType: "getAvailableNetworks",
                              requestId: requestId});
   },
 
+  getIMEI: function getIMEI(requestId) {
+    this.worker.postMessage({rilMessageType: "getIMEI",
+                             requestId: requestId});
+  },
+
   sendMMI: function sendMMI(message) {
     debug("SendMMI " + JSON.stringify(message));
     message.rilMessageType = "sendMMI";
     this.worker.postMessage(message);
   },
 
   cancelMMI: function cancelMMI(message) {
     // Some MMI codes trigger radio operations, but unfortunately the RIL only
diff --git a/dom/system/gonk/nsIRadioInterfaceLayer.idl b/dom/system/gonk/nsIRadioInterfaceLayer.idl
--- a/dom/system/gonk/nsIRadioInterfaceLayer.idl
+++ b/dom/system/gonk/nsIRadioInterfaceLayer.idl
@@ -149,17 +149,17 @@ interface nsIRILCellBroadcastCallback : 
    */
   void notifyMessageReceived(in nsIDOMMozCellBroadcastMessage message);
 };
 
 /**
  * Helper that runs in the content process and exposes information
  * to the DOM.
  */
-[scriptable, uuid(8c35c286-7a84-410d-9b36-b15f2cadf78f)]
+[scriptable, uuid(0e80c594-279a-406a-aa7a-b82bc79ef672)]
 interface nsIRILContentHelper : nsIMobileConnectionProvider
 {
   void registerTelephonyCallback(in nsIRILTelephonyCallback callback);
   void unregisterTelephonyCallback(in nsIRILTelephonyCallback callback);
 
   void registerVoicemailCallback(in nsIRILVoicemailCallback callback);
   void unregisterVoicemailCallback(in nsIRILVoicemailCallback callback);
 
@@ -212,16 +212,18 @@ interface nsIRILContentHelper : nsIMobil
   void startTone(in DOMString dtmfChar);
   void stopTone();
 
   void answerCall(in unsigned long callIndex);
   void rejectCall(in unsigned long callIndex);
   void holdCall(in unsigned long callIndex);
   void resumeCall(in unsigned long callIndex);
 
+  nsIDOMDOMRequest getIMEI(in nsIDOMWindow window);
+
   attribute bool microphoneMuted;
   attribute bool speakerEnabled;
 
   readonly attribute nsIDOMMozVoicemailStatus voicemailStatus;
   readonly attribute DOMString voicemailNumber;
   readonly attribute DOMString voicemailDisplayName;
 };
 
diff --git a/dom/system/gonk/ril_worker.js b/dom/system/gonk/ril_worker.js
--- a/dom/system/gonk/ril_worker.js
+++ b/dom/system/gonk/ril_worker.js
@@ -5790,22 +5790,20 @@ RIL[REQUEST_SET_CALL_FORWARD] =
 RIL[REQUEST_QUERY_CALL_WAITING] = null;
 RIL[REQUEST_SET_CALL_WAITING] = function REQUEST_SET_CALL_WAITING(length, options) {
   options.errorMsg = RIL_ERROR_TO_GECKO_ERROR[options.rilRequestError];
   this.sendDOMMessage(options);
 };
 RIL[REQUEST_SMS_ACKNOWLEDGE] = null;
 RIL[REQUEST_GET_IMEI] = function REQUEST_GET_IMEI(length, options) {
   this.IMEI = Buf.readString();
-  // So far we only send the IMEI back to the DOM if it was requested via MMI.
-  if (!options.mmi) {
-    return;
+  if (options.mmi) {
+    options.rilMessageType = "sendMMI";
   }
 
-  options.rilMessageType = "sendMMI";
   options.success = options.rilRequestError == 0;
   options.errorMsg = RIL_ERROR_TO_GECKO_ERROR[options.rilRequestError];
   if ((!options.success || this.IMEI == null) && !options.errorMsg) {
     options.errorMsg = GECKO_ERROR_GENERIC_FAILURE;
   }
   options.result = this.IMEI;
   this.sendDOMMessage(options);
 };
diff --git a/toolkit/mozapps/update/nsUpdateService.js b/toolkit/mozapps/update/nsUpdateService.js
--- a/toolkit/mozapps/update/nsUpdateService.js
+++ b/toolkit/mozapps/update/nsUpdateService.js
@@ -187,16 +187,23 @@ var gLocale     = null;
 var gVolumeMountLock = null;
 XPCOMUtils.defineLazyGetter(this, "gExtStorage", function aus_gExtStorage() {
     return Services.env.get("EXTERNAL_STORAGE");
 });
 
 var gSDCardMountLock = null;
 #endif
 
+#ifdef MOZ_B2G_RIL
+XPCOMUtils.defineLazyServiceGetter(this, "ril",
+                                   "@mozilla.org/ril/content-helper;1",
+                                   "nsIRILContentHelper");
+#endif
+
+
 XPCOMUtils.defineLazyModuleGetter(this, "UpdateChannel",
                                   "resource://gre/modules/UpdateChannel.jsm");
 
 XPCOMUtils.defineLazyGetter(this, "gLogEnabled", function aus_gLogEnabled() {
   return getPref("getBoolPref", PREF_APP_UPDATE_LOG, false);
 });
 
 XPCOMUtils.defineLazyGetter(this, "gUpdateBundle", function aus_gUpdateBundle() {
@@ -820,19 +827,19 @@ function isInterruptedUpdate(status) {
          (status == STATE_PENDING) ||
          (status == STATE_APPLYING);
 }
 #endif // MOZ_WIDGET_GONK
 
 /**
  * Releases any SDCard mount lock that we might have.
  *
- * This once again allows the SDCard to be shared with the PC. 
- *  
- * This function was placed outside the #ifdef so that we didn't 
+ * This once again allows the SDCard to be shared with the PC.
+ *
+ * This function was placed outside the #ifdef so that we didn't
  * need to put #ifdefs around the callers
  */
 function releaseSDCardMountLock() {
 #ifdef MOZ_WIDGET_GONK
   if (gSDCardMountLock) {
     gSDCardMountLock.unlock();
     gSDCardMountLock = null;
   }
@@ -2923,59 +2930,78 @@ Checker.prototype = {
    */
   _callback : null,
 
   /**
    * The URL of the update service XML file to connect to that contains details
    * about available updates.
    */
   getUpdateURL: function UC_getUpdateURL(force) {
-    this._forced = force;
-
-    // Use the override URL if specified.
-    var url = getPref("getCharPref", PREF_APP_UPDATE_URL_OVERRIDE, null);
-
-    // Otherwise, construct the update URL from component parts.
-    if (!url) {
-      try {
-        url = Services.prefs.getDefaultBranch(null).
-              getCharPref(PREF_APP_UPDATE_URL);
-      } catch (e) {
+
+    function _getUpdateURL() {
+      this._forced = force;
+
+      // Use the override URL if specified.
+      var url = getPref("getCharPref", PREF_APP_UPDATE_URL_OVERRIDE, null);
+
+      // Otherwise, construct the update URL from component parts.
+      if (!url) {
+        try {
+          url = Services.prefs.getDefaultBranch(null).
+                getCharPref(PREF_APP_UPDATE_URL);
+        } catch (e) {
+        }
       }
-    }
-
-    if (!url || url == "") {
-      LOG("Checker:getUpdateURL - update URL not defined");
-      return null;
-    }
-
-    url = url.replace(/%PRODUCT%/g, Services.appinfo.name);
-    url = url.replace(/%VERSION%/g, Services.appinfo.version);
-    url = url.replace(/%BUILD_ID%/g, Services.appinfo.appBuildID);
-    url = url.replace(/%BUILD_TARGET%/g, Services.appinfo.OS + "_" + gABI);
-    url = url.replace(/%OS_VERSION%/g, gOSVersion);
-    if (/%LOCALE%/.test(url))
-      url = url.replace(/%LOCALE%/g, getLocale());
-    url = url.replace(/%CHANNEL%/g, UpdateChannel.get());
-    url = url.replace(/%PLATFORM_VERSION%/g, Services.appinfo.platformVersion);
-    url = url.replace(/%DISTRIBUTION%/g,
-                      getDistributionPrefValue(PREF_APP_DISTRIBUTION));
-    url = url.replace(/%DISTRIBUTION_VERSION%/g,
-                      getDistributionPrefValue(PREF_APP_DISTRIBUTION_VERSION));
-    url = url.replace(/\+/g, "%2B");
+
+      if (!url || url == "") {
+        LOG("Checker:getUpdateURL - update URL not defined");
+        return null;
+      }
+
+      url = url.replace(/%PRODUCT%/g, Services.appinfo.name);
+      url = url.replace(/%VERSION%/g, Services.appinfo.version);
+      url = url.replace(/%BUILD_ID%/g, Services.appinfo.appBuildID);
+      url = url.replace(/%BUILD_TARGET%/g, Services.appinfo.OS + "_" + gABI);
+      url = url.replace(/%OS_VERSION%/g, gOSVersion);
+      if (/%LOCALE%/.test(url))
+        url = url.replace(/%LOCALE%/g, getLocale());
+      url = url.replace(/%CHANNEL%/g, UpdateChannel.get());
+      url = url.replace(/%PLATFORM_VERSION%/g, Services.appinfo.platformVersion);
+      url = url.replace(/%DISTRIBUTION%/g,
+                        getDistributionPrefValue(PREF_APP_DISTRIBUTION));
+      url = url.replace(/%DISTRIBUTION_VERSION%/g,
+                        getDistributionPrefValue(PREF_APP_DISTRIBUTION_VERSION));
+      url = url.replace(/\+/g, "%2B");
 
 #ifdef MOZ_WIDGET_GONK
-    url = url.replace(/%PRODUCT_MODEL%/g, gProductModel);
+      url = url.replace(/%PRODUCT_MODEL%/g, gProductModel);
 #endif
 
-    if (force)
-      url += (url.indexOf("?") != -1 ? "&" : "?") + "force=1";
-
-    LOG("Checker:getUpdateURL - update URL: " + url);
-    return url;
+      if (force)
+        url += (url.indexOf("?") != -1 ? "&" : "?") + "force=1";
+
+      if (this.imei)
+        url += (url.indexOf("?") != -1 ? "&" : "?") + "imei=" + this.imei;
+
+      LOG("Checker:getUpdateURL - update URL: " + url);
+      return url;
+    };
+
+    // We concat the device's IMEI to the update URL for dogfooding purposes.
+    let window = Services.wm.getMostRecentWindow("navigator:browser");
+    let req = ril.getIMEI(window);
+    req.onsuccess = (function onImei(evt) {
+      this.imei = evt.target.result
+      _getUpdateURL.bind(this)();
+    }).bind(this);
+    req.onerror = (function onError(evt) {
+      this.imei = null;
+      dump("Error getting IMEI " + evt.target.error.name + "\n");
+      _getUpdateURL.bind(this)();
+    }).bind(this);
   },
 
   /**
    * See nsIUpdateService.idl
    */
   checkForUpdates: function UC_checkForUpdates(listener, force) {
     LOG("Checker: checkForUpdates, force: " + force);
     if (!listener)
